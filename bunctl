#!/bin/bash

# bunctl - A pm2-like tool for managing Bun applications with systemd
# Version: 2.2.0
# Place this in /usr/local/bin/bunctl and chmod +x

set -e

# Configuration
SYSTEMD_DIR="/etc/systemd/system"
SERVICE_PREFIX="bun-app"
SITES_DIR="/var/www/sites"  # Adjust this to your sites directory
CONFIG_DIR="$HOME/.config/bunctl"
DB_FILE="$CONFIG_DIR/apps.db"
VERSION="2.2.0"

# Colors - using printf-compatible format
RED=$'\e[0;31m'
GREEN=$'\e[0;32m'
YELLOW=$'\e[1;33m'
BLUE=$'\e[0;34m'
CYAN=$'\e[0;36m'
MAGENTA=$'\e[0;35m'
NC=$'\e[0m' # No Color

# Ensure config directory exists
mkdir -p "$CONFIG_DIR"
mkdir -p "$CONFIG_DIR/backups"
touch "$DB_FILE"

# Helper functions
log_success() { echo -e "${GREEN}‚úÖ${NC} $1"; }
log_error() { echo -e "${RED}‚ùå${NC} $1"; }
log_info() { echo -e "${BLUE}‚ÑπÔ∏è${NC} $1"; }
log_warn() { echo -e "${YELLOW}‚ö†Ô∏è${NC} $1"; }

get_app_name() {
    local path="$1"
    # Generate app name from path
    echo "$path" | sed "s|$SITES_DIR/||" | sed 's|/|-|g' | sed 's|[^a-zA-Z0-9-]||g'
}

get_service_name() {
    echo "${SERVICE_PREFIX}-$1"
}

# Format memory size with appropriate units
format_memory() {
    local kb="$1"
    if [[ -z "$kb" ]] || [[ "$kb" == "0" ]]; then
        echo "-"
        return
    fi
    
    # Convert KB to appropriate unit
    if [[ $kb -lt 1024 ]]; then
        echo "${kb} KB"
    elif [[ $kb -lt 1048576 ]]; then
        echo "$(awk "BEGIN {printf \"%.1f\", $kb/1024}") MB"
    else
        echo "$(awk "BEGIN {printf \"%.1f\", $kb/1048576}") GB"
    fi
}

# Auto-detect common entry files
auto_detect_entry() {
    local app_dir="$1"
    
    # Check for .bunctl.json config first
    if [[ -f "$app_dir/.bunctl.json" ]] && command -v jq &> /dev/null; then
        local config_entry=$(jq -r '.entry // ""' "$app_dir/.bunctl.json" 2>/dev/null)
        if [[ -n "$config_entry" ]] && [[ -f "$app_dir/$config_entry" ]]; then
            echo "$config_entry"
            return 0
        fi
    fi
    
    # Common entry file patterns
    local patterns=(
        "src/server.ts" "src/index.ts" "src/main.ts" "src/app.ts"
        "server.ts" "index.ts" "main.ts" "app.ts"
        "src/server.js" "src/index.js" "src/main.js" "src/app.js"
        "server.js" "index.js" "main.js" "app.js"
        "private/server.ts" "private/index.ts" "private/main.ts"
    )
    
    for file in "${patterns[@]}"; do
        if [[ -f "$app_dir/$file" ]]; then
            echo "$file"
            return 0
        fi
    done
    
    echo "index.ts"  # Default fallback
}

# Load config from .bunctl.json if exists
load_config() {
    local app_dir="$1"
    local config_file="$app_dir/.bunctl.json"
    
    if [[ -f "$config_file" ]] && command -v jq &> /dev/null; then
        export BUNCTL_CONFIG="$config_file"
        export BUNCTL_NAME=$(jq -r '.name // ""' "$config_file" 2>/dev/null)
        export BUNCTL_ENTRY=$(jq -r '.entry // ""' "$config_file" 2>/dev/null)
        export BUNCTL_PORT=$(jq -r '.port // ""' "$config_file" 2>/dev/null)
        export BUNCTL_ENV=$(jq -r '.env // {}' "$config_file" 2>/dev/null)
        export BUNCTL_MEMORY=$(jq -r '.memory // "512M"' "$config_file" 2>/dev/null)
        export BUNCTL_CPU=$(jq -r '.cpu // "50"' "$config_file" 2>/dev/null)
        export BUNCTL_AUTOSTART=$(jq -r '.autostart // true' "$config_file" 2>/dev/null)
        export BUNCTL_RESTART_DELAY=$(jq -r '.restart_delay // "10"' "$config_file" 2>/dev/null)
        export BUNCTL_MAX_RESTARTS=$(jq -r '.max_restarts // "3"' "$config_file" 2>/dev/null)
        export BUNCTL_RUNTIME=$(jq -r '.runtime // "bun"' "$config_file" 2>/dev/null)
        return 0
    fi
    
    return 1
}

# Initialize/add an app in current directory
init_app() {
    local app_dir="$(pwd)"
    local app_name="${1:-}"
    local entry_file="${2:-}"
    local port="${3:-}"
    
    # Load config if exists
    if load_config "$app_dir"; then
        log_info "Using configuration from .bunctl.json"
        
        # Use values from config file if not provided via CLI
        if [[ -z "$app_name" ]] && [[ -n "$BUNCTL_NAME" ]]; then
            app_name="$BUNCTL_NAME"
            log_info "Using app name from config: $app_name"
        fi
        
        if [[ -z "$entry_file" ]] && [[ -n "$BUNCTL_ENTRY" ]]; then
            entry_file="$BUNCTL_ENTRY"
            log_info "Using entry file from config: $entry_file"
        fi
        
        if [[ -z "$port" ]] && [[ -n "$BUNCTL_PORT" ]]; then
            port="$BUNCTL_PORT"
        fi
    fi
    
    # Generate app name if still not set
    if [[ -z "$app_name" ]]; then
        app_name=$(get_app_name "$app_dir")
    fi
    
    # Auto-detect entry file if not provided
    if [[ -z "$entry_file" ]]; then
        entry_file=$(auto_detect_entry "$app_dir")
        log_info "Auto-detected entry file: $entry_file"
    fi

    # Check if we're in a valid directory
    if [[ ! "$app_dir" == "$SITES_DIR"* ]]; then
        log_warn "Current directory is not under $SITES_DIR"
        read -p "Continue anyway? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            exit 1
        fi
    fi

    # Check if entry file exists
    if [[ ! -f "$app_dir/$entry_file" ]]; then
        log_error "Entry file not found: $entry_file"
        log_info "Looking in: $app_dir/$entry_file"
        exit 1
    fi

    local service_name=$(get_service_name "$app_name")
    local service_file="$SYSTEMD_DIR/$service_name.service"

    # Determine working directory
    local working_dir="$app_dir"

    log_info "Creating service: $service_name"
    
    # Rotate logs if they exist (backup previous run)
    if [[ -f "$app_dir/logs/app.log" ]]; then
        mv "$app_dir/logs/app.log" "$app_dir/logs/app.$(date +%Y%m%d_%H%M%S).log" 2>/dev/null || true
        # Keep only last 10 log files
        ls -t "$app_dir/logs"/app.*.log 2>/dev/null | tail -n +11 | xargs rm -f 2>/dev/null || true
    fi
    if [[ -f "$app_dir/logs/error.log" ]]; then
        mv "$app_dir/logs/error.log" "$app_dir/logs/error.$(date +%Y%m%d_%H%M%S).log" 2>/dev/null || true
        # Keep only last 10 log files
        ls -t "$app_dir/logs"/error.*.log 2>/dev/null | tail -n +11 | xargs rm -f 2>/dev/null || true
    fi
    
    # Find Bun executable - check common locations
    local bun_path=""
    # Try which first as it's most reliable
    if command -v bun &> /dev/null; then
        bun_path=$(which bun)
    else
        # Check common locations if which doesn't work
        for path in /usr/local/bin/bun /usr/bin/bun $HOME/.bun/bin/bun /home/*/.bun/bin/bun; do
            if [[ -x "$path" ]]; then
                bun_path="$path"
                break
            fi
        done
    fi
    
    if [[ -z "$bun_path" ]]; then
        log_error "Bun executable not found! Please ensure Bun is installed."
        log_info "Install with: curl -fsSL https://bun.sh/install | bash"
        exit 1
    fi
    
    log_info "Using Bun at: $bun_path"
    
    # Determine runtime flags
    local runtime_flag=""
    if [[ "${BUNCTL_RUNTIME:-bun}" == "bun" ]]; then
        runtime_flag="--bun"
        log_info "Runtime mode: Bun (fast, native)"
    else
        runtime_flag=""
        log_info "Runtime mode: Node.js compatibility"
    fi

    # Create service file with enhanced features
    sudo tee "$service_file" > /dev/null << EOF
[Unit]
Description=Bun App - $app_name
After=network.target
StartLimitIntervalSec=60
StartLimitBurst=3

[Service]
Type=simple
User=$(whoami)
Group=www-data
WorkingDirectory=$working_dir
ExecStartPre=/bin/sh -c 'echo "\\n===== Service started at \$(date +\"%%Y-%%m-%%d %%H:%%M:%%S\") =====" >> $app_dir/logs/app.log'
ExecStart=/bin/sh -c '$bun_path $runtime_flag $working_dir/$entry_file 2>&1 | while IFS= read -r line; do echo "[\$(date +\"%%Y-%%m-%%d %%H:%%M:%%S\")] \$line"; done >> $app_dir/logs/app.log 2>> $app_dir/logs/error.log'
ExecStopPost=/bin/sh -c 'echo "===== Service stopped at \$(date +\"%%Y-%%m-%%d %%H:%%M:%%S\") =====\\n" >> $app_dir/logs/app.log'
Restart=always
RestartSec=${BUNCTL_RESTART_DELAY:-10}
StartLimitBurst=${BUNCTL_MAX_RESTARTS:-3}
SyslogIdentifier=$app_name
Environment="NODE_ENV=production"
EOF

    # Add environment file if it exists
    if [[ -f "$app_dir/config/.env" ]]; then
        echo "EnvironmentFile=$app_dir/config/.env" | sudo tee -a "$service_file" > /dev/null
    elif [[ -f "$app_dir/.env" ]]; then
        echo "EnvironmentFile=$app_dir/.env" | sudo tee -a "$service_file" > /dev/null
    fi

    # Add port if specified
    if [[ -n "$port" ]]; then
        echo "Environment=\"PORT=$port\"" | sudo tee -a "$service_file" > /dev/null
    fi
    
    # Add environment variables from config
    if [[ -n "$BUNCTL_ENV" ]] && [[ "$BUNCTL_ENV" != "{}" ]]; then
        echo "$BUNCTL_ENV" | jq -r 'to_entries[] | "Environment=\"\(.key)=\(.value)\""' | sudo tee -a "$service_file" > /dev/null
    fi

    # Add resource limits
    local memory_limit="${BUNCTL_MEMORY:-512M}"
    local cpu_quota="${BUNCTL_CPU:-50}"
    
    sudo tee -a "$service_file" > /dev/null << EOF

# Resource limits
MemoryMax=$memory_limit
CPUQuota=${cpu_quota}%
TasksMax=100

# Security
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=read-only
ReadWritePaths=$app_dir

[Install]
WantedBy=multi-user.target
EOF

    # Create logs directory if it doesn't exist
    mkdir -p "$app_dir/logs"

    # Save to database
    echo "$app_name|$app_dir|$entry_file|$(date +%s)|enabled" >> "$DB_FILE"

    # Reload systemd
    sudo systemctl daemon-reload
    
    # Enable for boot if autostart is true (default)
    if [[ "${BUNCTL_AUTOSTART:-true}" == "true" ]]; then
        sudo systemctl enable "$service_name" 2>/dev/null
        log_info "Service will auto-start on boot"
    else
        log_info "Auto-start on boot is disabled (per config)"
    fi

    log_success "Service created: $service_name"
    log_info "Start with: bunctl start $app_name"
}

# Set environment variable for an app
set_env() {
    local app_name="$1"
    local env_var="$2"
    
    if [[ -z "$env_var" ]] || [[ ! "$env_var" =~ ^[A-Z_][A-Z0-9_]*=.+$ ]]; then
        log_error "Invalid environment variable format. Use: KEY=value"
        exit 1
    fi
    
    local service_name=$(get_service_name "$app_name")
    local service_file="$SYSTEMD_DIR/$service_name.service"
    
    if [[ ! -f "$service_file" ]]; then
        log_error "Service not found: $app_name"
        exit 1
    fi
    
    # Add environment variable to service file
    sudo sed -i "/^\[Service\]/a Environment=\"$env_var\"" "$service_file"
    sudo systemctl daemon-reload
    
    log_success "Environment variable added: $env_var"
    log_info "Restart the app to apply: bunctl restart $app_name"
}

# Health check for an app
health_check() {
    local app_name="$1"
    local service_name=$(get_service_name "$app_name")
    
    if ! systemctl list-units --all --no-legend | grep -q "$service_name"; then
        log_error "App not found: $app_name"
        exit 1
    fi
    
    echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
    echo -e "${CYAN}Health Report: $app_name${NC}"
    echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
    
    local status=$(systemctl is-active "$service_name")
    local enabled=$(systemctl is-enabled "$service_name" 2>/dev/null || echo "disabled")
    local pid=$(systemctl show "$service_name" --property=MainPID --value)
    local active_time=$(systemctl show "$service_name" --property=ActiveEnterTimestamp --value)
    local restarts=$(systemctl show "$service_name" --property=NRestarts --value)
    local memory=$(systemctl show "$service_name" --property=MemoryCurrent --value)
    
    # Status indicator
    if [[ "$status" == "active" ]]; then
        echo -e "Status:       ${GREEN}üü¢ Healthy${NC}"
    elif [[ "$status" == "failed" ]]; then
        echo -e "Status:       ${RED}üî¥ Failed${NC}"
    else
        echo -e "Status:       ${YELLOW}üü° Inactive${NC}"
    fi
    
    echo -e "Boot startup: $([ "$enabled" = "enabled" ] && echo "${GREEN}‚úÖ Enabled${NC}" || echo "${YELLOW}‚ö†Ô∏è  Disabled${NC}")"
    
    if [[ "$pid" != "0" ]] && [[ -n "$pid" ]]; then
        echo -e "PID:          $pid"
        
        # Calculate uptime if active
        if [[ -n "$active_time" ]] && [[ "$active_time" != "n/a" ]]; then
            local uptime_seconds=$(( $(date +%s) - $(date -d "$active_time" +%s) ))
            local days=$((uptime_seconds / 86400))
            local hours=$(( (uptime_seconds % 86400) / 3600 ))
            local minutes=$(( (uptime_seconds % 3600) / 60 ))
            echo -e "Uptime:       ${days}d ${hours}h ${minutes}m"
        fi
        
        # Memory usage (using ps for more accurate reading)
        local mem_kb=$(ps -o rss= -p "$pid" 2>/dev/null | tr -d ' ' || echo "0")
        if [[ -n "$mem_kb" ]] && [[ "$mem_kb" != "0" ]]; then
            local formatted_mem=$(format_memory "$mem_kb")
            echo -e "Memory:       $formatted_mem"
        fi
    fi
    
    echo -e "Restarts:     $restarts"
    
    # Show recent logs if failed
    if [[ "$status" == "failed" ]]; then
        echo
        echo -e "${RED}Recent error logs:${NC}"
        sudo journalctl -u "$service_name" -n 5 --no-pager
    fi
}

# Backup service configurations
backup_services() {
    local backup_name="${1:-backup}"
    local backup_dir="$CONFIG_DIR/backups/${backup_name}_$(date +%Y%m%d_%H%M%S)"
    mkdir -p "$backup_dir"
    
    log_info "Creating backup in: $backup_dir"
    
    # Backup service files
    local count=0
    local services=$(systemctl list-units --all --no-legend --no-pager --plain "${SERVICE_PREFIX}-*" 2>/dev/null | grep "^${SERVICE_PREFIX}-" | awk '{print $1}')
    if [[ -n "$services" ]]; then
        while IFS= read -r service; do
            if [[ -n "$service" ]] && [[ "$service" =~ ^${SERVICE_PREFIX}- ]]; then
                local service_file="$SYSTEMD_DIR/$service"
                if [[ -f "$service_file" ]]; then
                    sudo cp "$service_file" "$backup_dir/" 2>/dev/null || true
                    count=$((count + 1))
                fi
            fi
        done <<< "$services"
    fi
    
    # Backup database
    cp "$DB_FILE" "$backup_dir/" 2>/dev/null || true
    
    # Create backup metadata
    cat > "$backup_dir/metadata.json" << EOF
{
    "version": "$VERSION",
    "date": "$(date -Iseconds)",
    "services": $count,
    "user": "$(whoami)",
    "hostname": "$(hostname)"
}
EOF
    
    log_success "Backup created: $count services backed up"
    echo "Backup location: $backup_dir"
}

# Restore from backup
restore_services() {
    local backup_path="$1"
    
    if [[ ! -d "$backup_path" ]]; then
        # Try to find in default backup directory
        backup_path="$CONFIG_DIR/backups/$backup_path"
        if [[ ! -d "$backup_path" ]]; then
            log_error "Backup not found: $1"
            log_info "Available backups:"
            ls -la "$CONFIG_DIR/backups/" 2>/dev/null | grep "^d" | awk '{print "  - " $NF}'
            exit 1
        fi
    fi
    
    log_warn "This will restore services from: $backup_path"
    read -p "Continue? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        exit 0
    fi
    
    # Restore service files
    local count=0
    for service_file in "$backup_path"/*.service; do
        if [[ -f "$service_file" ]]; then
            sudo cp "$service_file" "$SYSTEMD_DIR/" 2>/dev/null || true
            count=$((count + 1))
        fi
    done
    
    # Restore database
    if [[ -f "$backup_path/apps.db" ]]; then
        cp "$backup_path/apps.db" "$DB_FILE"
    fi
    
    # Reload systemd
    sudo systemctl daemon-reload
    
    log_success "Restored $count services from backup"
}

# Create systemd service for boot startup
install_boot_service() {
    local boot_service_file="$SYSTEMD_DIR/bunctl-autostart.service"
    
    log_info "Installing boot autostart service..."
    
    sudo tee "$boot_service_file" > /dev/null << EOF
[Unit]
Description=Bunctl - Start all Bun applications on boot
After=network.target multi-user.target
Wants=network-online.target

[Service]
Type=oneshot
ExecStart=/usr/local/bin/bunctl start-all
RemainAfterExit=yes
StandardOutput=journal
StandardError=journal
User=root

[Install]
WantedBy=multi-user.target
EOF
    
    sudo systemctl daemon-reload
    sudo systemctl enable bunctl-autostart.service
    
    log_success "Boot autostart service installed and enabled"
    log_info "All enabled apps will start automatically on system boot"
}

# Remove boot service
uninstall_boot_service() {
    log_info "Removing boot autostart service..."
    
    sudo systemctl disable bunctl-autostart.service 2>/dev/null || true
    sudo rm -f "$SYSTEMD_DIR/bunctl-autostart.service"
    sudo systemctl daemon-reload
    
    log_success "Boot autostart service removed"
}

# Group operations
restart_group() {
    local pattern="$1"
    
    if [[ -z "$pattern" ]]; then
        log_error "Pattern required. Example: bunctl restart-group 'api-*'"
        exit 1
    fi
    
    log_info "Restarting apps matching pattern: $pattern"
    
    local count=0
    for service in $(systemctl list-units --all --no-legend "${SERVICE_PREFIX}-${pattern}" | awk '{print $1}'); do
        local app_name=$(echo "$service" | sed "s/${SERVICE_PREFIX}-//" | sed 's/.service//')
        sudo systemctl restart "$service"
        log_success "Restarted: $app_name"
        count=$((count + 1))
    done
    
    if [[ $count -eq 0 ]]; then
        log_warn "No apps found matching pattern: $pattern"
    else
        log_success "Restarted $count apps"
    fi
}

# JSON output for status
show_status_json() {
    echo '{"apps":['
    
    local first=true
    local services=$(systemctl list-units --all --no-legend --no-pager --plain "${SERVICE_PREFIX}-*" 2>/dev/null | grep "^${SERVICE_PREFIX}-" | awk '{print $1}')
    if [[ -n "$services" ]]; then
        while IFS= read -r service; do
            if [[ -z "$service" ]] || [[ ! "$service" =~ ^${SERVICE_PREFIX}- ]]; then
                continue
            fi
        local app_name=$(echo "$service" | sed "s/${SERVICE_PREFIX}-//" | sed 's/.service//')
        local status=$(systemctl is-active "$service")
        local enabled=$(systemctl is-enabled "$service" 2>/dev/null || echo "disabled")
        local pid=$(systemctl show "$service" --property=MainPID --value)
        local memory=$(systemctl show "$service" --property=MemoryCurrent --value)
        local restarts=$(systemctl show "$service" --property=NRestarts --value)
        
        if [[ "$first" != true ]]; then
            echo ","
        fi
        first=false
        
        # Clean up memory value
        if [[ "$memory" == "[not set]" ]] || [[ "$memory" == "18446744073709551615" ]]; then
            memory="0"
        fi
        
        printf '    {"name":"%s","status":"%s","enabled":"%s","pid":%s,"memory":%s,"restarts":%s}' \
            "$app_name" "$status" "$enabled" "$pid" "$memory" "$restarts"
        done <<< "$services"
    fi
    
    echo
    echo ']}'
}

# Start an app
start_app() {
    local app_name="$1"
    local service_name=$(get_service_name "$app_name")
    local service_file="$SYSTEMD_DIR/$service_name.service"
    
    # Get working directory for log rotation
    if [[ -f "$service_file" ]]; then
        local working_dir=$(grep "^WorkingDirectory=" "$service_file" | sed 's/^WorkingDirectory=//')
        
        # Rotate logs before starting
        if [[ -f "$working_dir/logs/app.log" ]]; then
            mv "$working_dir/logs/app.log" "$working_dir/logs/app.$(date +%Y%m%d_%H%M%S).log" 2>/dev/null || true
            # Keep only last 10 log files
            ls -t "$working_dir/logs"/app.*.log 2>/dev/null | tail -n +11 | xargs rm -f 2>/dev/null || true
        fi
        if [[ -f "$working_dir/logs/error.log" ]]; then
            mv "$working_dir/logs/error.log" "$working_dir/logs/error.$(date +%Y%m%d_%H%M%S).log" 2>/dev/null || true
            # Keep only last 10 log files
            ls -t "$working_dir/logs"/error.*.log 2>/dev/null | tail -n +11 | xargs rm -f 2>/dev/null || true
        fi
    fi

    sudo systemctl start "$service_name"
    sudo systemctl enable "$service_name" 2>/dev/null

    if systemctl is-active --quiet "$service_name"; then
        log_success "Started: $app_name"
    else
        log_error "Failed to start: $app_name"
        exit 1
    fi
}

# Stop an app
stop_app() {
    local app_name="$1"
    local service_name=$(get_service_name "$app_name")

    sudo systemctl stop "$service_name"
    log_success "Stopped: $app_name"
}

# Restart an app
restart_app() {
    local app_name="$1"
    local service_name=$(get_service_name "$app_name")
    local service_file="$SYSTEMD_DIR/$service_name.service"
    
    # Get working directory for log rotation
    if [[ -f "$service_file" ]]; then
        local working_dir=$(grep "^WorkingDirectory=" "$service_file" | sed 's/^WorkingDirectory=//')
        
        # Rotate logs before restarting
        if [[ -f "$working_dir/logs/app.log" ]]; then
            mv "$working_dir/logs/app.log" "$working_dir/logs/app.$(date +%Y%m%d_%H%M%S).log" 2>/dev/null || true
            # Keep only last 10 log files
            ls -t "$working_dir/logs"/app.*.log 2>/dev/null | tail -n +11 | xargs rm -f 2>/dev/null || true
        fi
        if [[ -f "$working_dir/logs/error.log" ]]; then
            mv "$working_dir/logs/error.log" "$working_dir/logs/error.$(date +%Y%m%d_%H%M%S).log" 2>/dev/null || true
            # Keep only last 10 log files
            ls -t "$working_dir/logs"/error.*.log 2>/dev/null | tail -n +11 | xargs rm -f 2>/dev/null || true
        fi
    fi

    sudo systemctl restart "$service_name"
    log_success "Restarted: $app_name"
}

# Delete an app
delete_app() {
    local app_name="$1"
    local service_name=$(get_service_name "$app_name")
    local service_file="$SYSTEMD_DIR/$service_name.service"

    # Stop and disable service
    sudo systemctl stop "$service_name" 2>/dev/null || true
    sudo systemctl disable "$service_name" 2>/dev/null || true

    # Remove service file
    sudo rm -f "$service_file"

    # Remove from database
    grep -v "^$app_name|" "$DB_FILE" > "$DB_FILE.tmp" || true
    mv "$DB_FILE.tmp" "$DB_FILE"

    # Reload systemd
    sudo systemctl daemon-reload

    log_success "Deleted: $app_name"
}

# Show status of all apps
show_status() {
    # Check for JSON output
    if [[ "${2:-}" == "--json" ]]; then
        show_status_json
        return
    fi
    
    echo
    echo -e "${BLUE}‚îÅ‚îÅ‚îÅ Bun Applications Status ‚îÅ‚îÅ‚îÅ${NC}"
    echo
    
    local has_apps=false
    # Get services more carefully
    local services=$(systemctl list-units --all --no-legend --no-pager --plain "${SERVICE_PREFIX}-*" 2>/dev/null | grep "^${SERVICE_PREFIX}-" | awk '{print $1}')
    
    if [[ -z "$services" ]]; then
        echo -e "  ${YELLOW}No applications found${NC}"
        echo
        return
    fi
    
    while IFS= read -r service; do
        # Skip if service is empty or invalid
        if [[ -z "$service" ]] || [[ ! "$service" =~ ^${SERVICE_PREFIX}- ]]; then
            continue
        fi
        has_apps=true
        local app_name=$(echo "$service" | sed "s/${SERVICE_PREFIX}-//" | sed 's/.service//')
        local status=$(systemctl is-active "$service")
        local enabled=$(systemctl is-enabled "$service" 2>/dev/null || echo "disabled")
        local pid="-"
        local memory="-"
        local cpu="-"

        # Status icon and text
        local status_display
        if [[ "$status" == "active" ]]; then
            status_display="${GREEN}‚óè RUNNING${NC}"
            pid=$(systemctl show "$service" --property=MainPID --value)
            if [[ "$pid" != "0" ]] && [[ -n "$pid" ]]; then
                local mem_kb=$(ps -o rss= -p "$pid" 2>/dev/null | tr -d ' ' || echo "0")
                memory=$(format_memory "$mem_kb")
                cpu=$(ps -o %cpu= -p "$pid" 2>/dev/null | awk '{printf "%.1f%%", $1}' || echo "-")
            else
                pid="-"
            fi
        elif [[ "$status" == "failed" ]]; then
            status_display="${RED}‚úñ FAILED${NC}"
        else
            status_display="${YELLOW}‚óã STOPPED${NC}"
        fi
        
        # Boot status
        local boot_status=""
        if [[ "$enabled" == "enabled" ]]; then
            boot_status="${GREEN}[boot]${NC}"
        fi
        
        # Display app info
        echo -e "  ${CYAN}$app_name${NC} $boot_status"
        echo -e "    Status:  $status_display"
        if [[ "$pid" != "-" ]]; then
            echo -e "    PID:     $pid"
            echo -e "    Memory:  $memory"
            echo -e "    CPU:     $cpu"
        fi
        echo
    done <<< "$services"
    
    if [[ "$has_apps" == false ]]; then
        echo -e "  ${YELLOW}No applications found${NC}"
        echo
    fi
}

# Show logs for an app or all apps
show_logs() {
    # Parse arguments
    local app_name=""
    local lines="100"  # Default to 100 lines like pm2
    local follow_mode=false
    
    # Parse all arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -f|--follow)
                follow_mode=true
                shift
                ;;
            -n|--lines)
                if [[ -n "$2" ]] && [[ "$2" =~ ^[0-9]+$ ]]; then
                    lines="$2"
                    shift 2
                else
                    log_error "Invalid line count after -n"
                    exit 1
                fi
                ;;
            -*)
                log_error "Unknown option: $1"
                log_info "Usage: bunctl logs [app-name] [-n lines] [-f]"
                exit 1
                ;;
            *)
                if [[ -z "$app_name" ]]; then
                    app_name="$1"
                fi
                shift
                ;;
        esac
    done
    
    # If app_name is specified, show logs for that app
    if [[ -n "$app_name" ]]; then
        show_single_app_logs "$app_name" "$lines" "$follow_mode"
    else
        # Show logs for all apps
        show_all_apps_logs "$lines" "$follow_mode"
    fi
}

# Show logs for a single app
show_single_app_logs() {
    local app_name="$1"
    local lines="$2"
    local follow_mode="$3"
    
    # Get app info from database or service file
    local service_name=$(get_service_name "$app_name")
    local service_file="$SYSTEMD_DIR/$service_name.service"
    
    if [[ ! -f "$service_file" ]]; then
        log_error "Service not found: $app_name"
        exit 1
    fi
    
    # Get working directory from service file
    local working_dir=$(grep "^WorkingDirectory=" "$service_file" | sed 's/^WorkingDirectory=//')
    local app_log="$working_dir/logs/app.log"
    local error_log="$working_dir/logs/error.log"
    
    # Check if log files exist
    if [[ ! -f "$app_log" ]] && [[ ! -f "$error_log" ]]; then
        log_warn "No log files found for $app_name"
        log_info "Log files expected at:"
        log_info "  - $app_log"
        log_info "  - $error_log"
        return
    fi
    
    if [[ "$follow_mode" == true ]]; then
        # Follow both log files
        log_info "Following logs for $app_name (Ctrl+C to stop)..."
        echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
        
        # Use tail to follow with app name prefix
        if [[ -f "$app_log" ]]; then
            tail -f -n "$lines" "$app_log" | sed "s/^/${CYAN}[$app_name]${NC} /" &
        fi
        if [[ -f "$error_log" ]] && [[ -s "$error_log" ]]; then
            tail -f -n "$lines" "$error_log" | sed "s/^/${RED}[$app_name:ERROR]${NC} /" &
        fi
        wait
    else
        # Show recent logs from both files
        echo -e "${CYAN}‚îÅ‚îÅ‚îÅ Logs for $app_name ‚îÅ‚îÅ‚îÅ${NC}"
        
        if [[ -f "$app_log" ]]; then
            echo -e "${GREEN}[APP LOG]${NC}"
            tail -n "$lines" "$app_log"
            echo
        fi
        
        if [[ -f "$error_log" ]] && [[ -s "$error_log" ]]; then
            echo -e "${RED}[ERROR LOG]${NC}"
            tail -n "$lines" "$error_log"
            echo
        fi
        
        echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
    fi
}

# Show logs for all apps
show_all_apps_logs() {
    local lines="$1"
    local follow_mode="$2"
    
    # Get all service files
    local services=$(systemctl list-units --all --no-legend --no-pager --plain "${SERVICE_PREFIX}-*" 2>/dev/null | grep "^${SERVICE_PREFIX}-" | awk '{print $1}')
    
    if [[ -z "$services" ]]; then
        log_warn "No applications found"
        return
    fi
    
    # Collect all log files
    local log_files=()
    local app_names=()
    
    while IFS= read -r service; do
        if [[ -n "$service" ]] && [[ "$service" =~ ^${SERVICE_PREFIX}- ]]; then
            local app_name=$(echo "$service" | sed "s/${SERVICE_PREFIX}-//" | sed 's/.service//')
            local service_file="$SYSTEMD_DIR/${SERVICE_PREFIX}-${app_name}.service"
            
            if [[ -f "$service_file" ]]; then
                local working_dir=$(grep "^WorkingDirectory=" "$service_file" | sed 's/^WorkingDirectory=//')
                local app_log="$working_dir/logs/app.log"
                
                if [[ -f "$app_log" ]]; then
                    log_files+=("$app_log")
                    app_names+=("$app_name")
                fi
            fi
        fi
    done <<< "$services"
    
    if [[ ${#log_files[@]} -eq 0 ]]; then
        log_warn "No log files found for any application"
        return
    fi
    
    if [[ "$follow_mode" == true ]]; then
        log_info "Following logs for all applications (Ctrl+C to stop)..."
        echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
        
        # Start tail for each log file with app name prefix
        for i in "${!log_files[@]}"; do
            local log_file="${log_files[$i]}"
            local app="${app_names[$i]}"
            tail -f -n "$lines" "$log_file" | while IFS= read -r line; do
                echo -e "${CYAN}[$app]${NC} $line"
            done &
        done
        
        # Wait for all background processes
        wait
    else
        echo -e "${CYAN}‚îÅ‚îÅ‚îÅ All Applications Logs (last $lines lines) ‚îÅ‚îÅ‚îÅ${NC}"
        echo
        
        # Create a temporary file for merged logs
        local temp_file=$(mktemp)
        
        # Collect logs from all apps with app name prefix
        for i in "${!log_files[@]}"; do
            local log_file="${log_files[$i]}"
            local app="${app_names[$i]}"
            
            # Get more lines from each file to ensure we have enough after merging
            # (get N lines from each app, then we'll filter to N total after sorting)
            tail -n "$lines" "$log_file" 2>/dev/null | while IFS= read -r line; do
                # Extract timestamp if present
                if [[ "$line" =~ ^\[([0-9]{4}-[0-9]{2}-[0-9]{2}\ [0-9]{2}:[0-9]{2}:[0-9]{2})\] ]]; then
                    echo "${BASH_REMATCH[1]} ${CYAN}[$app]${NC} $line"
                elif [[ "$line" =~ ^=====.*([0-9]{4}-[0-9]{2}-[0-9]{2}\ [0-9]{2}:[0-9]{2}:[0-9]{2}) ]]; then
                    # Handle service start/stop markers
                    echo "${BASH_REMATCH[1]} ${CYAN}[$app]${NC} $line"
                else
                    # For lines without timestamps, use a placeholder that sorts early
                    echo "1970-01-01 00:00:00 ${CYAN}[$app]${NC} $line"
                fi
            done >> "$temp_file"
        done
        
        # Sort by timestamp and display
        sort "$temp_file" | tail -n "$lines" | while IFS= read -r line; do
            # Remove the temporary timestamp used for sorting
            echo -e "${line:20}"
        done
        
        rm -f "$temp_file"
        
        echo
        echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
    fi
}

# List all apps
list_apps() {
    # Check for JSON output
    if [[ "${2:-}" == "--json" ]]; then
        show_status_json
        return
    fi
    
    echo
    echo -e "${BLUE}‚îÅ‚îÅ‚îÅ Registered Applications ‚îÅ‚îÅ‚îÅ${NC}"
    echo

    local count=0
    # Get services more carefully
    local services=$(systemctl list-units --all --no-legend --no-pager --plain "${SERVICE_PREFIX}-*" 2>/dev/null | grep "^${SERVICE_PREFIX}-" | awk '{print $1}')
    
    if [[ -z "$services" ]]; then
        echo -e "  ${YELLOW}No applications found${NC}"
        echo
        return
    fi
    
    while IFS= read -r service; do
        # Skip if service is empty or invalid
        if [[ -z "$service" ]] || [[ ! "$service" =~ ^${SERVICE_PREFIX}- ]]; then
            continue
        fi
        local app_name=$(echo "$service" | sed "s/${SERVICE_PREFIX}-//" | sed 's/.service//')
        local status=$(systemctl is-active "$service")
        local enabled=$(systemctl is-enabled "$service" 2>/dev/null || echo "disabled")
        local app_info=$(grep "^$app_name|" "$DB_FILE" 2>/dev/null | head -1)
        local app_dir=$(echo "$app_info" | cut -d'|' -f2)

        # Status indicator
        local status_icon
        if [[ "$status" == "active" ]]; then
            status_icon="${GREEN}‚óè${NC}"
        elif [[ "$status" == "failed" ]]; then
            status_icon="${RED}‚úñ${NC}"
        else
            status_icon="${YELLOW}‚óã${NC}"
        fi
        
        # Boot indicator
        local boot_marker=""
        if [[ "$enabled" == "enabled" ]]; then
            boot_marker=" ${GREEN}[boot]${NC}"
        fi

        echo -e "  $status_icon ${CYAN}$app_name${NC}$boot_marker"
        if [[ -n "$app_dir" ]]; then
            echo -e "    ${BLUE}‚Üí${NC} $app_dir"
        fi
        
        count=$((count + 1))
    done <<< "$services"

    if [[ $count -eq 0 ]]; then
        echo -e "  ${YELLOW}No applications found${NC}"
    fi
    echo
}

# Scan and import existing directories
scan_import() {
    log_info "Scanning $SITES_DIR for Bun applications..."

    local found=0
    for site_dir in "$SITES_DIR"/*; do
        if [[ ! -d "$site_dir" ]]; then
            continue
        fi

        # Auto-detect entry file
        cd "$site_dir"
        local entry_file=$(auto_detect_entry "$site_dir")
        
        if [[ -f "$site_dir/$entry_file" ]]; then
            local app_name=$(get_app_name "$site_dir")
            log_info "Found: $site_dir (entry: $entry_file)"
            read -p "Import this app? (y/N): " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                init_app "$app_name" "$entry_file"
                ((found++))
            fi
        fi
    done

    log_success "Scan complete. Imported $found applications."
}

# Show help
show_help() {
    echo -e "${BLUE}bunctl${NC} - Bun Application Manager for systemd ${CYAN}v$VERSION${NC}"
    echo
    echo -e "${YELLOW}Usage:${NC}"
    echo "  bunctl <command> [options]"
    echo
    echo -e "${YELLOW}Recommended Workflow:${NC}"
    echo -e "  ${GREEN}generate-config${NC}         Create .bunctl.json config file (RECOMMENDED)"
    echo -e "  ${GREEN}init${NC}                    Initialize service from config file"
    echo
    echo -e "${YELLOW}Core Commands:${NC}"
    echo -e "  ${GREEN}init${NC} [name] [entry]     Create service (uses config if present)"
    echo -e "  ${GREEN}start${NC} <name>            Start an application"
    echo -e "  ${GREEN}stop${NC} <name>             Stop an application"
    echo -e "  ${GREEN}restart${NC} <name>          Restart an application"
    echo -e "  ${GREEN}delete${NC} <name>           Remove an application"
    echo -e "  ${GREEN}status${NC} [--json]         Show status of all applications"
    echo -e "  ${GREEN}list${NC} [--json]           List all applications"
    echo -e "  ${GREEN}logs${NC} [name] [-n N] [-f] Show logs (all apps if no name)"
    echo -e "  ${GREEN}flush${NC} [name]            Clear logs (all if no name)"
    echo
    echo -e "${YELLOW}Advanced Commands:${NC}"
    echo -e "  ${GREEN}update${NC}                  Update all services (fix paths, etc.)"
    echo -e "  ${GREEN}health${NC} <name>           Show detailed health report"
    echo -e "  ${GREEN}env${NC} <name> KEY=val      Set environment variable"
    echo -e "  ${GREEN}backup${NC} [name]           Backup all service configurations"
    echo -e "  ${GREEN}restore${NC} <backup>        Restore from backup"
    echo -e "  ${GREEN}scan${NC}                    Scan and import apps from $SITES_DIR"
    echo
    echo -e "${YELLOW}Boot Management:${NC}"
    echo -e "  ${GREEN}install-boot${NC}            Enable auto-start on system boot"
    echo -e "  ${GREEN}uninstall-boot${NC}          Disable auto-start on system boot"
    echo
    echo -e "${YELLOW}Bulk Operations:${NC}"
    echo -e "  ${GREEN}start-all${NC}               Start all applications"
    echo -e "  ${GREEN}stop-all${NC}                Stop all applications"
    echo -e "  ${GREEN}restart-all${NC}             Restart all applications"
    echo -e "  ${GREEN}restart-group${NC} <pattern> Restart apps matching pattern"
    echo
    echo -e "${YELLOW}Examples:${NC}"
    echo
    echo "  ${CYAN}# Recommended approach using config file:${NC}"
    echo "  cd /var/www/sites/myapp"
    echo "  bunctl generate-config     # Creates .bunctl.json"
    echo "  # Edit .bunctl.json to customize settings"
    echo "  bunctl init               # Reads config and creates service"
    echo
    echo "  ${CYAN}# Quick setup without config:${NC}"
    echo "  bunctl init myapp src/server.ts"
    echo "  bunctl health myapp"
    echo "  bunctl env myapp PORT=3000"
    echo "  bunctl restart-group 'api-*'"
    echo "  bunctl status --json | jq '.apps[]'"
    echo
    echo "  ${CYAN}# Logs examples:${NC}"
    echo "  bunctl logs                # Show last 100 lines from ALL apps"
    echo "  bunctl logs -n 200         # Show last 200 lines from ALL apps"
    echo "  bunctl logs -f             # Follow ALL apps logs in real-time"
    echo "  bunctl logs myapp          # Show last 100 lines from myapp"
    echo "  bunctl logs myapp -n 50    # Show last 50 lines from myapp"
    echo "  bunctl logs myapp -f       # Follow myapp logs in real-time"
    echo "  bunctl logs -f -n 500      # Follow all logs, start with 500 lines"
    echo
    echo -e "${YELLOW}Configuration File (.bunctl.json):${NC}"
    echo "  The config file is the ${GREEN}recommended approach${NC} for managing apps."
    echo
    echo -e "  ${CYAN}Full config example:${NC}"
    echo -e "  ${CYAN}{"
    echo -e "    \"name\": \"my-api\",           ${CYAN}// App name${NC}"
    echo -e "    \"entry\": \"src/server.ts\",   ${CYAN}// Entry point${NC}"
    echo -e "    \"port\": 3000,               ${CYAN}// Port number${NC}"
    echo -e "    \"runtime\": \"bun\",           ${CYAN}// Runtime: 'bun' or 'node'${NC}"
    echo -e "    \"memory\": \"1G\",             ${CYAN}// Memory limit${NC}"
    echo -e "    \"cpu\": 75,                  ${CYAN}// CPU quota %${NC}"
    echo -e "    \"autostart\": true,          ${CYAN}// Start on boot${NC}"
    echo -e "    \"restart_delay\": 10,        ${CYAN}// Seconds before restart${NC}"
    echo -e "    \"max_restarts\": 3,          ${CYAN}// Max restart attempts${NC}"
    echo -e "    \"env\": {                    ${CYAN}// Environment variables${NC}"
    echo -e "      \"NODE_ENV\": \"production\""
    echo -e "    }"
    echo -e "  }${NC}"
    echo
}

# Generate config file template
generate_config() {
    local config_file=".bunctl.json"
    local force="${1:-}"
    
    # Check if config already exists
    if [[ -f "$config_file" ]] && [[ "$force" != "--force" ]]; then
        log_warn "Config file already exists: $config_file"
        log_info "Use 'bunctl generate-config --force' to overwrite"
        exit 1
    fi
    
    # Auto-detect current setup
    local detected_entry=$(auto_detect_entry "$(pwd)")
    local suggested_name=$(basename "$(pwd)")
    
    log_info "Generating .bunctl.json configuration file..."
    
    cat > "$config_file" << EOF
{
  "name": "$suggested_name",
  "entry": "$detected_entry",
  "port": 3000,
  "runtime": "bun",
  "memory": "512M",
  "cpu": 50,
  "autostart": true,
  "restart_delay": 10,
  "max_restarts": 3,
  "env": {
    "NODE_ENV": "production"
  }
}
EOF
    
    log_success "Created $config_file"
    log_info "Configuration file generated with detected settings:"
    echo -e "${CYAN}  ‚Ä¢ Name:${NC} $suggested_name"
    echo -e "${CYAN}  ‚Ä¢ Entry:${NC} $detected_entry"
    echo
    log_info "Edit the file to customize your settings, then run:"
    echo -e "${GREEN}  bunctl init${NC}"
    echo
    log_info "The config file is the recommended way to configure your app!"
}

# Update all services (refresh service files)
update_services() {
    log_info "Regenerating all service files with current configuration..."
    
    # Find Bun executable
    local bun_path=""
    # Try which first as it's most reliable
    if command -v bun &> /dev/null; then
        bun_path=$(which bun)
    else
        # Check common locations if which doesn't work
        for path in /usr/local/bin/bun /usr/bin/bun $HOME/.bun/bin/bun /home/*/.bun/bin/bun; do
            if [[ -x "$path" ]]; then
                bun_path="$path"
                break
            fi
        done
    fi
    
    if [[ -z "$bun_path" ]]; then
        log_error "Bun executable not found!"
        exit 1
    fi
    
    log_info "Using Bun at: $bun_path"
    
    local count=0
    # Look for service files directly in the systemd directory
    for service_file in "$SYSTEMD_DIR"/${SERVICE_PREFIX}-*.service; do
        if [[ -f "$service_file" ]]; then
            local service_name=$(basename "$service_file" .service)
            local app_name=$(echo "$service_name" | sed "s/${SERVICE_PREFIX}-//")
            log_info "Updating service: $service_name"
            
            # Extract current configuration from service file
            local working_dir=$(grep "^WorkingDirectory=" "$service_file" | sed 's/^WorkingDirectory=//')
            local user=$(grep "^User=" "$service_file" | sed 's/^User=//')
            local current_exec=$(grep "^ExecStart=" "$service_file" || echo "")
            local entry_file=$(echo "$current_exec" | sed 's/^ExecStart=.*bun run //' | sed 's/^ExecStart=.*bun //' | sed "s|$working_dir/||" | sed 's|^/||')
            
            # Load config if exists
            local memory_limit="512M"
            local cpu_quota="50"
            local restart_delay="10"
            local max_restarts="3"
            local runtime="bun"
            
            if [[ -f "$working_dir/.bunctl.json" ]] && command -v jq &> /dev/null; then
                memory_limit=$(jq -r '.memory // "512M"' "$working_dir/.bunctl.json" 2>/dev/null || echo "512M")
                cpu_quota=$(jq -r '.cpu // "50"' "$working_dir/.bunctl.json" 2>/dev/null || echo "50")
                restart_delay=$(jq -r '.restart_delay // "10"' "$working_dir/.bunctl.json" 2>/dev/null || echo "10")
                max_restarts=$(jq -r '.max_restarts // "3"' "$working_dir/.bunctl.json" 2>/dev/null || echo "3")
                runtime=$(jq -r '.runtime // "bun"' "$working_dir/.bunctl.json" 2>/dev/null || echo "bun")
            fi
            
            # Determine runtime flags
            local runtime_flag=""
            if [[ "$runtime" == "bun" ]]; then
                runtime_flag="--bun"
            fi
            
            # Regenerate entire service file
            sudo tee "$service_file" > /dev/null << EOF
[Unit]
Description=Bun App - $app_name
After=network.target
StartLimitIntervalSec=60
StartLimitBurst=3

[Service]
Type=simple
User=$user
Group=www-data
WorkingDirectory=$working_dir
ExecStartPre=/bin/sh -c 'echo "\\n===== Service started at \$(date +\"%%Y-%%m-%%d %%H:%%M:%%S\") =====" >> $working_dir/logs/app.log'
ExecStart=/bin/sh -c '$bun_path $runtime_flag $working_dir/$entry_file 2>&1 | while IFS= read -r line; do echo "[\$(date +\"%%Y-%%m-%%d %%H:%%M:%%S\")] \$line"; done >> $working_dir/logs/app.log 2>> $working_dir/logs/error.log'
ExecStopPost=/bin/sh -c 'echo "===== Service stopped at \$(date +\"%%Y-%%m-%%d %%H:%%M:%%S\") =====\\n" >> $working_dir/logs/app.log'
Restart=always
RestartSec=$restart_delay
StartLimitBurst=$max_restarts
SyslogIdentifier=$app_name
Environment="NODE_ENV=production"
EOF

            # Add environment file if it exists
            if [[ -f "$working_dir/config/.env" ]]; then
                echo "EnvironmentFile=$working_dir/config/.env" | sudo tee -a "$service_file" > /dev/null
            elif [[ -f "$working_dir/.env" ]]; then
                echo "EnvironmentFile=$working_dir/.env" | sudo tee -a "$service_file" > /dev/null
            fi
            
            # Add config environment variables if exists
            if [[ -f "$working_dir/.bunctl.json" ]] && command -v jq &> /dev/null; then
                local env_vars=$(jq -r '.env // {} | to_entries[] | "Environment=\"\(.key)=\(.value)\""' "$working_dir/.bunctl.json" 2>/dev/null)
                if [[ -n "$env_vars" ]]; then
                    echo "$env_vars" | sudo tee -a "$service_file" > /dev/null
                fi
                
                local port=$(jq -r '.port // ""' "$working_dir/.bunctl.json" 2>/dev/null)
                if [[ -n "$port" ]] && [[ "$port" != "null" ]]; then
                    echo "Environment=\"PORT=$port\"" | sudo tee -a "$service_file" > /dev/null
                fi
            fi

            # Add resource limits and security
            sudo tee -a "$service_file" > /dev/null << EOF

# Resource limits
MemoryMax=$memory_limit
CPUQuota=${cpu_quota}%
TasksMax=100

# Security
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=read-only
ReadWritePaths=$working_dir

[Install]
WantedBy=multi-user.target
EOF
            
            count=$((count + 1))
            log_success "Regenerated: $service_name"
        fi
    done
    
    # Reload systemd
    sudo systemctl daemon-reload
    
    if [[ $count -eq 0 ]]; then
        log_warn "No services found to update"
        log_info "Make sure you have initialized apps with 'bunctl init'"
    else
        log_success "Updated $count services"
        log_info "Restart services for changes to take effect: bunctl restart-all"
    fi
}

# Flush logs for apps
flush_logs() {
    local app_name="$1"
    
    if [[ -z "$app_name" ]]; then
        log_info "Flushing logs for all applications..."
        
        # Clear systemd journal for all bun services
        services=$(systemctl list-units --all --no-legend --no-pager --plain "${SERVICE_PREFIX}-*" 2>/dev/null | grep "^${SERVICE_PREFIX}-" | awk '{print $1}')
        if [[ -n "$services" ]]; then
            while IFS= read -r service; do
                if [[ -n "$service" ]] && [[ "$service" =~ ^${SERVICE_PREFIX}- ]]; then
                    sudo journalctl --rotate --vacuum-time=1s -u "$service" 2>/dev/null || true
                    local app=$(echo "$service" | sed "s/${SERVICE_PREFIX}-//" | sed 's/.service//')
                    log_success "Flushed logs: $app"
                fi
            done <<< "$services"
        fi
        
        # Also clear log files if they exist
        for dir in "$SITES_DIR"/*/logs; do
            if [[ -d "$dir" ]]; then
                sudo truncate -s 0 "$dir"/*.log 2>/dev/null || true
            fi
        done
    else
        local service_name=$(get_service_name "$app_name")
        
        # Clear systemd journal for specific service
        sudo journalctl --rotate --vacuum-time=1s -u "$service_name" 2>/dev/null || true
        
        # Clear log files if they exist
        local app_info=$(grep "^$app_name|" "$DB_FILE" 2>/dev/null | head -1)
        local app_dir=$(echo "$app_info" | cut -d'|' -f2)
        if [[ -n "$app_dir" ]] && [[ -d "$app_dir/logs" ]]; then
            sudo truncate -s 0 "$app_dir/logs"/*.log 2>/dev/null || true
        fi
        
        log_success "Flushed logs for: $app_name"
    fi
}

# Install shell completion
install_completion() {
    local completion_file="/etc/bash_completion.d/bunctl"
    
    log_info "Installing shell completion..."
    
    sudo tee "$completion_file" > /dev/null << 'EOF'
# Bash completion for bunctl
_bunctl() {
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"
    
    local commands="init generate-config start stop restart delete status list logs flush update health env backup restore scan install-boot uninstall-boot start-all stop-all restart-all restart-group help"
    
    if [[ ${COMP_CWORD} -eq 1 ]]; then
        COMPREPLY=($(compgen -W "${commands}" -- ${cur}))
    elif [[ ${COMP_CWORD} -eq 2 ]]; then
        case "${prev}" in
            start|stop|restart|delete|logs|health|env)
                # Get app names
                local apps=$(bunctl list 2>/dev/null | grep -E "^  [üü¢üî¥üü°]" | sed 's/^  [üü¢üî¥üü°] //' | cut -d' ' -f1)
                COMPREPLY=($(compgen -W "${apps}" -- ${cur}))
                ;;
            status|list)
                COMPREPLY=($(compgen -W "--json" -- ${cur}))
                ;;
        esac
    fi
}
complete -F _bunctl bunctl
EOF
    
    log_success "Shell completion installed"
    log_info "Reload your shell or run: source /etc/bash_completion.d/bunctl"
}

# Main command handler
case "${1:-}" in
    init)
        # Smart argument detection for init command
        if [[ -n "$2" ]] && [[ "$2" == *"/"* || "$2" == *".ts" || "$2" == *".js" ]]; then
            # First argument looks like a file path, treat it as entry file
            init_app "" "$2" "$3"
        else
            # Traditional usage: name, entry, port
            init_app "$2" "$3" "$4"
        fi
        ;;
    start)
        if [[ -z "$2" ]]; then
            log_error "App name required"
            exit 1
        fi
        start_app "$2"
        ;;
    stop)
        if [[ -z "$2" ]]; then
            log_error "App name required"
            exit 1
        fi
        stop_app "$2"
        ;;
    restart)
        if [[ -z "$2" ]]; then
            log_error "App name required"
            exit 1
        fi
        restart_app "$2"
        ;;
    delete|rm)
        if [[ -z "$2" ]]; then
            log_error "App name required"
            exit 1
        fi
        delete_app "$2"
        ;;
    status|ps)
        show_status "$@"
        ;;
    list|ls)
        list_apps "$@"
        ;;
    logs|log)
        # Pass all arguments to show_logs for proper parsing
        shift  # Remove 'logs' from arguments
        show_logs "$@"
        ;;
    health)
        if [[ -z "$2" ]]; then
            log_error "App name required"
            exit 1
        fi
        health_check "$2"
        ;;
    env)
        if [[ -z "$2" ]] || [[ -z "$3" ]]; then
            log_error "Usage: bunctl env <app> KEY=value"
            exit 1
        fi
        set_env "$2" "$3"
        ;;
    backup)
        backup_services "$2"
        ;;
    restore)
        if [[ -z "$2" ]]; then
            log_error "Backup name or path required"
            exit 1
        fi
        restore_services "$2"
        ;;
    generate-config)
        generate_config "$2"
        ;;
    update)
        update_services
        ;;
    flush)
        flush_logs "$2"
        ;;
    scan|import)
        scan_import
        ;;
    install-boot)
        install_boot_service
        ;;
    uninstall-boot)
        uninstall_boot_service
        ;;
    install-completion)
        install_completion
        ;;
    restart-group)
        if [[ -z "$2" ]]; then
            log_error "Pattern required"
            exit 1
        fi
        restart_group "$2"
        ;;
    reload)
        sudo systemctl daemon-reload
        log_success "Systemd daemon reloaded"
        ;;
    start-all)
        services=$(systemctl list-units --all --no-legend --no-pager --plain "${SERVICE_PREFIX}-*" 2>/dev/null | grep "^${SERVICE_PREFIX}-" | awk '{print $1}')
        if [[ -z "$services" ]]; then
            log_warn "No applications found to start"
        else
            while IFS= read -r service; do
                if [[ -n "$service" ]] && [[ "$service" =~ ^${SERVICE_PREFIX}- ]]; then
                    sudo systemctl start "$service" 2>/dev/null || true
                    log_success "Started: $(echo $service | sed "s/${SERVICE_PREFIX}-//" | sed 's/.service//')"
                fi
            done <<< "$services"
        fi
        ;;
    stop-all)
        services=$(systemctl list-units --all --no-legend --no-pager --plain "${SERVICE_PREFIX}-*" 2>/dev/null | grep "^${SERVICE_PREFIX}-" | awk '{print $1}')
        if [[ -z "$services" ]]; then
            log_warn "No applications found to stop"
        else
            while IFS= read -r service; do
                if [[ -n "$service" ]] && [[ "$service" =~ ^${SERVICE_PREFIX}- ]]; then
                    sudo systemctl stop "$service" 2>/dev/null || true
                    log_success "Stopped: $(echo $service | sed "s/${SERVICE_PREFIX}-//" | sed 's/.service//')"
                fi
            done <<< "$services"
        fi
        ;;
    restart-all)
        services=$(systemctl list-units --all --no-legend --no-pager --plain "${SERVICE_PREFIX}-*" 2>/dev/null | grep "^${SERVICE_PREFIX}-" | awk '{print $1}')
        if [[ -z "$services" ]]; then
            log_warn "No applications found to restart"
        else
            while IFS= read -r service; do
                if [[ -n "$service" ]] && [[ "$service" =~ ^${SERVICE_PREFIX}- ]]; then
                    sudo systemctl restart "$service" 2>/dev/null || true
                    log_success "Restarted: $(echo $service | sed "s/${SERVICE_PREFIX}-//" | sed 's/.service//')"
                fi
            done <<< "$services"
        fi
        ;;
    version|--version|-v)
        echo "bunctl version $VERSION"
        ;;
    help|--help|-h|"")
        show_help
        ;;
    *)
        log_error "Unknown command: $1"
        show_help
        exit 1
        ;;
esac
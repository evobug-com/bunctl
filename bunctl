#!/usr/bin/env bash
# bunctl — production-grade process manager for Bun apps on systemd
# Rebuilt for reliability and clarity. Not backward compatible with 2.x service layout.
# Version: 3.0.0

set -Eeuo pipefail
IFS=$'\n\t'

# ----------------------------
# Globals & defaults
# ----------------------------
VERSION="3.0.0"
UNIT_BASENAME="bunctl@.service"         # template unit
UNIT_PREFIX="bunctl@"                    # instance prefix, e.g. bunctl@api.service

# Mode: "system" (root, services live in /etc/systemd/system)
#    or "user"   (non-root, services live in ~/.config/systemd/user)
MODE="${BUNCTL_MODE:-auto}"

XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
CFG_DIR="$XDG_CONFIG_HOME/bunctl"
APPS_DIR="$CFG_DIR/apps"                 # per-app json configs (optional)
ENV_DIR_SYSTEM="/etc/bunctl"             # env files for system units
ENV_DIR_USER="$CFG_DIR/env"              # env files for user units
LOG_ID_PREFIX="bunctl"                   # journald syslog identifier prefix

# Colors (disable if not a tty)
if [[ -t 1 ]]; then
  RED=$'\e[31m'; GREEN=$'\e[32m'; YELLOW=$'\e[33m'; BLUE=$'\e[34m'; MAGENTA=$'\e[35m'; CYAN=$'\e[36m'; BOLD=$'\e[1m'; RESET=$'\e[0m'
else
  RED=""; GREEN=""; YELLOW=""; BLUE=""; MAGENTA=""; CYAN=""; BOLD=""; RESET=""
fi

debug=false
if [[ "${BUNCTL_DEBUG:-}" == "1" ]] || [[ "${1:-}" == "--debug" ]]; then
  debug=true
  set -x
  [[ "${1:-}" == "--debug" ]] && shift
fi

# ----------------------------
# Utils
# ----------------------------
die() { echo >&2 "${RED}✖ ${1}${RESET}"; exit "${2:-1}"; }
info(){ echo "${BLUE}ℹ ${1}${RESET}"; }
ok()  { echo "${GREEN}✔ ${1}${RESET}"; }
warn(){ echo "${YELLOW}⚠ ${1}${RESET}"; }
dbg() { $debug && echo >&2 "${MAGENTA}[debug] ${1}${RESET}" || true; }

require_cmd() { command -v "$1" >/dev/null 2>&1 || die "Missing required command: $1"; }

is_root() { [[ "${EUID:-$(id -u)}" -eq 0 ]]; }

sc() {
  # Wrapper around systemctl honoring MODE and --user/--system override
  local sc_args=()
  if [[ "$MODE" == "auto" ]]; then
    if is_root; then sc_args=(); else sc_args=(--user); fi
  elif [[ "$MODE" == "user" ]]; then
    sc_args=(--user)
  else
    sc_args=()
  fi
  systemctl "${sc_args[@]}" "$@"
}

jc() {
  # journalctl wrapper for correct user/system context
  local jc_args=()
  if [[ "$MODE" == "auto" ]]; then
    if is_root; then jc_args=(); else jc_args=(--user); fi
  elif [[ "$MODE" == "user" ]]; then
    jc_args=(--user)
  else
    jc_args=()
  fi
  journalctl "${jc_args[@]}" "$@"
}

# sanitize app name to [a-z0-9-._]
sanitize_name() {
  local n="$1"
  n="${n// /-}"
  n="$(echo "$n" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9._-]+/-/g; s/^-+//; s/-+$//')"
  [[ -z "$n" ]] && die "Empty/invalid app name"
  printf "%s" "$n"
}

bun_path() {
  local p=""
  if command -v bun >/dev/null 2>&1; then p="$(command -v bun)"; fi
  if [[ -z "$p" ]]; then
    # common locations
    for cand in "$HOME/.bun/bin/bun" "/usr/local/bin/bun" "/usr/bin/bun"; do
      [[ -x "$cand" ]] && p="$cand" && break
    done
  fi
  [[ -z "$p" ]] && die "Bun executable not found. Install Bun and ensure it's on PATH."
  printf "%s" "$p"
}

# Resolve paths depending on mode
unit_dir() {
  if [[ "$MODE" == "user" || ( "$MODE" == "auto" && ! $(is_root) ) ]]; then
    printf "%s" "$HOME/.config/systemd/user"
  else
    printf "%s" "/etc/systemd/system"
  fi
}

unit_template_path() { printf "%s/%s" "$(unit_dir)" "$UNIT_BASENAME"; }

instance_unit_name() { printf "%s%s.service" "$UNIT_PREFIX" "$1"; }         # e.g. bunctl@api.service
instance_dropin_dir() { printf "%s/%s.d" "$(unit_dir)" "$(instance_unit_name "$1")"; }
instance_dropin() { printf "%s/10-bunctl.conf" "$(instance_dropin_dir "$1")"; }

env_file_path() {
  local name="$1"
  if [[ "$MODE" == "user" || ( "$MODE" == "auto" && ! $(is_root) ) ]]; then
    printf "%s/%s.env" "$ENV_DIR_USER" "$name"
  else
    printf "%s/%s.env" "$ENV_DIR_SYSTEM" "$name"
  fi
}

config_path() { printf "%s/%s.json" "$APPS_DIR" "$1"; }

# Ensure directories exist
ensure_dirs() {
  mkdir -p "$CFG_DIR" "$APPS_DIR" "$ENV_DIR_USER"
  if is_root; then mkdir -p "$ENV_DIR_SYSTEM"; fi
  mkdir -p "$(unit_dir)"
}

# ----------------------------
# Unit template
# ----------------------------
write_unit_template() {
  ensure_dirs
  local tpl="$(unit_template_path)"
  if [[ -f "$tpl" ]]; then
    dbg "Unit template already exists: $tpl"
    return
  fi
  info "Writing unit template: $tpl"
  cat >"$tpl" <<'UNIT'
[Unit]
Description=Bunctl app instance (%i)
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
# We allow both system and user env locations; missing files are ignored with '-'
EnvironmentFile=-/etc/bunctl/%i.env
EnvironmentFile=-%h/.config/bunctl/env/%i.env

# Default user/group can be overridden in a drop-in
User=%u
Group=%U

# ExecStart uses a small shell to support $CMD composed from env file.
# $CMD should be a full command line, e.g. "/usr/bin/bun run src/server.ts"
ExecStart=/bin/sh -lc 'exec $CMD'
ExecReload=/bin/kill -USR1 $MAINPID

# Restart policy & delays
Restart=always
RestartSec=10s
StartLimitIntervalSec=60
StartLimitBurst=3
TimeoutStopSec=15s
KillSignal=SIGTERM
SendSIGKILL=yes
KillMode=process
SyslogIdentifier=bunctl[%i]
StandardOutput=journal
StandardError=journal

# Reasonable defaults; instance drop-in can override
TasksMax=256
NoNewPrivileges=yes
PrivateTmp=yes
ProtectSystem=strict
ProtectHome=read-only
ProtectControlGroups=yes
ProtectKernelModules=yes
LockPersonality=yes
RestrictRealtime=yes
RestrictSUIDSGID=yes
CapabilityBoundingSet=

[Install]
WantedBy=default.target
UNIT
  sc daemon-reload
}

# ----------------------------
# Read / write env & drop-ins
# ----------------------------
kv_set() {
  # idempotent KEY=VALUE in a file
  local file="$1" key="$2" val="$3"
  mkdir -p "$(dirname "$file")"
  touch "$file"
  if grep -q -E "^${key}=" "$file"; then
    sed -i -E "s|^${key}=.*$|${key}=${val}|g" "$file"
  else
    printf "%s=%s\n" "$key" "$val" >>"$file"
  fi
}

kv_unset() {
  local file="$1" key="$2"
  [[ -f "$file" ]] || return 0
  sed -i -E "/^${key}=.*/d" "$file"
}

write_instance_dropin() {
  local name="$1" workdir="$2" memory="$3" cpu="$4" user_override="$5" group_override="$6"
  local d="$(instance_dropin_dir "$name")"
  mkdir -p "$d"
  local f="$(instance_dropin "$name")"
  cat >"$f" <<EOF
[Service]
WorkingDirectory=$workdir
$( [[ -n "$user_override" ]] && echo "User=$user_override" )
$( [[ -n "$group_override" ]] && echo "Group=$group_override" )
$( [[ -n "$memory" ]] && echo "MemoryMax=$memory" )
$( [[ -n "$cpu" ]] && echo "CPUQuota=$cpu%" )
EOF
}

# ----------------------------
# App discovery helpers
# ----------------------------
list_instances() {
  # print instance names without suffix
  sc list-units --all --no-legend "${UNIT_PREFIX}*.service" \
    | awk '{print $1}' | sed -E "s/^${UNIT_PREFIX}//; s/\.service$//" | sort -u
}

have_instance() {
  local name="$1"
  sc list-unit-files --no-legend | awk '{print $1}' | grep -q "^$(instance_unit_name "$name")$"
}

# ----------------------------
# Commands
# ----------------------------
cmd_init() {
  # bunctl init --name NAME [--entry FILE] [--port N] [--cwd DIR] [--memory 512M] [--cpu 50] [--user UNITUSER] [--group UNITGROUP] [--autostart] [--runtime bun|node]
  local name="" entry="" port="" cwd="" memory="512M" cpu="50" runtime="bun" autostart=false unit_user="" unit_group=""
  # parse flags
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --name) name="${2:-}"; shift 2;;
      --entry) entry="${2:-}"; shift 2;;
      --port) port="${2:-}"; shift 2;;
      --cwd) cwd="${2:-}"; shift 2;;
      --memory) memory="${2:-}"; shift 2;;
      --cpu) cpu="${2:-}"; shift 2;;
      --runtime) runtime="${2:-}"; shift 2;;
      --autostart) autostart=true; shift;;
      --user) unit_user="${2:-}"; shift 2;;
      --group) unit_group="${2:-}"; shift 2;;
      --system) MODE="system"; shift;;
      --user-unit|--user) MODE="user"; shift;;
      *) [[ -z "$name" ]] && name="$1" || { warn "Unknown arg: $1"; }; shift;;
    esac
  done

  [[ -z "${name:-}" ]] && name="$(basename "$(pwd)")"
  name="$(sanitize_name "$name")"

  [[ -z "$cwd" ]] && cwd="$(pwd)"
  [[ -z "$entry" ]] && {
    # auto-detect common entry files
    local try=( "src/server.ts" "src/index.ts" "src/app.ts" "server.ts" "index.ts" "app.ts" "src/server.js" "server.js" "index.js" )
    for f in "${try[@]}"; do
      [[ -f "$cwd/$f" ]] && entry="$f" && break
    done
  }
  [[ -z "$entry" ]] && die "Could not auto-detect entry file. Pass --entry FILE."

  local bun="$(bun_path)"

  ensure_dirs
  write_unit_template

  local env_file="$(env_file_path "$name")"
  # Compose CMD
  local cmd=""
  if [[ "$runtime" == "bun" ]]; then
    cmd="$bun run $entry"
  else
    require_cmd node
    cmd="$(command -v node) $entry"
  fi
  kv_set "$env_file" "CMD" "$cmd"
  kv_set "$env_file" "PORT" "${port:-}"
  kv_set "$env_file" "NODE_ENV" "production"

  write_instance_dropin "$name" "$cwd" "$memory" "$cpu" "$unit_user" "$unit_group"

  # Persist a small json (optional)
  mkdir -p "$APPS_DIR"
  cat >"$(config_path "$name")" <<EOF
{"name":"$name","entry":"$entry","port":"${port:-}","cwd":"$cwd","memory":"$memory","cpu":"$cpu","runtime":"$runtime","mode":"$MODE","version":"$VERSION"}
EOF

  sc daemon-reload
  if $autostart; then sc enable "$(instance_unit_name "$name")"; fi
  ok "Initialized app '${name}'"
  echo "• Working dir: $cwd"
  echo "• Entry:       $entry"
  echo "• Runtime:     $runtime"
  echo "• Env file:    $env_file"
  echo "• Unit:        $(unit_template_path) + $(instance_dropin "$name")"
  echo "Start it: bunctl start ${name}"
}

cmd_start()    { local name="$(sanitize_name "${1:-}")"; [[ -z "$name" ]] && die "Usage: bunctl start <name>"; sc start "$(instance_unit_name "$name")"; ok "Started ${name}"; }
cmd_stop()     { local name="$(sanitize_name "${1:-}")"; [[ -z "$name" ]] && die "Usage: bunctl stop <name>"; sc stop  "$(instance_unit_name "$name")"; ok "Stopped ${name}"; }
cmd_restart()  { local name="$(sanitize_name "${1:-}")"; [[ -z "$name" ]] && die "Usage: bunctl restart <name>"; sc restart "$(instance_unit_name "$name")"; ok "Restarted ${name}"; }
cmd_reload()   { local name="$(sanitize_name "${1:-}")"; [[ -z "$name" ]] && die "Usage: bunctl reload <name>"; sc reload "$(instance_unit_name "$name")" || { warn "Service did not handle reload; performing restart"; sc restart "$(instance_unit_name "$name")"; }; ok "Reloaded ${name}"; }
cmd_enable()   { local name="$(sanitize_name "${1:-}")"; [[ -z "$name" ]] && die "Usage: bunctl enable <name>"; sc enable "$(instance_unit_name "$name")"; ok "Enabled ${name} on boot"; }
cmd_disable()  { local name="$(sanitize_name "${1:-}")"; [[ -z "$name" ]] && die "Usage: bunctl disable <name>"; sc disable "$(instance_unit_name "$name")"; ok "Disabled ${name} on boot"; }

cmd_delete() {
  local name="$(sanitize_name "${1:-}")"; [[ -z "$name" ]] && die "Usage: bunctl delete <name>"
  local unit="$(instance_unit_name "$name")"
  sc stop "$unit" >/dev/null 2>&1 || true
  sc disable "$unit" >/dev/null 2>&1 || true
  rm -f -- "$(instance_dropin "$name")"
  rmdir --ignore-fail-on-non-empty "$(instance_dropin_dir "$name")" 2>/dev/null || true
  local envf="$(env_file_path "$name")"
  [[ -f "$envf" ]] && rm -f -- "$envf"
  sc daemon-reload
  ok "Deleted configuration for ${name}"
}

cmd_status() {
  # bunctl status [--json] [name]
  local json=false target=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --json) json=true; shift;;
      *) target="$1"; shift;;
    esac
  done

  if [[ -n "$target" ]]; then
    local unit="$(instance_unit_name "$(sanitize_name "$target")")"
    if $json; then
      # Produce one JSON object
      local s="$(sc show "$unit" --no-page --property=Id,ActiveState,MainPID,MemoryCurrent,CPUUsageNSec,NRestarts,ExecMainStatus 2>/dev/null || true)"
      [[ -z "$s" ]] && echo '{}' && return 0
      # shellcheck disable=SC2001
      echo '{' \
        "\"name\":\"$target\"," \
        "\"unit\":\"$unit\"," \
        "\"status\":\"$(echo "$s" | sed -n 's/^ActiveState=//p')\"," \
        "\"pid\":$(echo "$s" | sed -n 's/^MainPID=//p')," \
        "\"memory_bytes\":$(echo "$s" | sed -n 's/^MemoryCurrent=//p' | sed 's/[^0-9].*//')," \
        "\"restarts\":$(echo "$s" | sed -n 's/^NRestarts=//p')," \
        "\"exit_code\":$(echo "$s" | sed -n 's/^ExecMainStatus=//p')" \
      '}'
    else
      echo
      echo "${BOLD}Bun app: ${target}${RESET}"
      sc status "$unit" --no-pager || true
      echo
    fi
    return
  fi

  # All instances
  if $json; then
    echo '{"apps":['
    local first=true
    while read -r name; do
      [[ -z "$name" ]] && continue
      $first || echo ','
      first=false
      # inline JSON for each unit
      local unit="$(instance_unit_name "$name")"
      local s="$(sc show "$unit" --no-page --property=Id,ActiveState,MainPID,MemoryCurrent,CPUUsageNSec,NRestarts,ExecMainStatus 2>/dev/null || true)"
      if [[ -n "$s" ]]; then
        echo -n '{'
        echo -n "\"name\":\"$name\","
        echo -n "\"unit\":\"$unit\","
        echo -n "\"status\":\"$(echo "$s" | sed -n 's/^ActiveState=//p')\","
        echo -n "\"pid\":$(echo "$s" | sed -n 's/^MainPID=//p'),"
        echo -n "\"memory_bytes\":$(echo "$s" | sed -n 's/^MemoryCurrent=//p' | sed 's/[^0-9].*//'),"
        echo -n "\"restarts\":$(echo "$s" | sed -n 's/^NRestarts=//p'),"
        echo -n "\"exit_code\":$(echo "$s" | sed -n 's/^ExecMainStatus=//p')"
        echo -n '}'
      fi
    done < <(list_instances)
    echo ']}'
    return
  fi

  echo
  echo "${BOLD}━━━ Bun Applications Status ━━━${RESET}"
  echo
  local any=false
  while read -r name; do
    [[ -z "$name" ]] && continue
    any=true
    local unit="$(instance_unit_name "$name")"
    local active="$(sc is-active "$unit" 2>/dev/null || true)"
    local enabled="$(sc is-enabled "$unit" 2>/dev/null || echo disabled)"
    local pid="$(sc show "$unit" --property=MainPID --value 2>/dev/null || echo 0)"
    local mem="$(sc show "$unit" --property=MemoryCurrent --value 2>/dev/null || echo 0)"
    # humanize mem (kB based)
    local mem_h="-"
    if [[ "$mem" =~ ^[0-9]+$ ]] && [[ "$mem" -gt 0 ]]; then
      if (( mem < 1024 )); then mem_h="${mem}B"
      elif (( mem < 1048576 )); then mem_h="$((mem/1024)) KB"
      elif (( mem < 1073741824 )); then mem_h="$(awk "BEGIN{printf \"%.1f MB\", $mem/1048576}")"
      else mem_h="$(awk "BEGIN{printf \"%.1f GB\", $mem/1073741824}")"
      fi
    fi
    local status_text
    if [[ "$active" == "active" ]]; then
      status_text="${GREEN}● RUNNING${RESET}"
    elif [[ "$active" == "failed" ]]; then
      status_text="${RED}✖ FAILED${RESET}"
    else
      status_text="${YELLOW}○ STOPPED${RESET}"
    fi
    printf "  %s\n" "${CYAN}${name}${RESET} ${enabled:+[$enabled]}"
    printf "    Status:  %b\n" "$status_text"
    [[ "$pid" != "0" ]] && printf "    PID:     %s\n" "$pid"
    [[ "$mem_h" != "-" ]] && printf "    Memory:  %s\n" "$mem_h"
    echo
  done < <(list_instances)
  $any || { echo "  ${YELLOW}No applications found${RESET}"; echo; }
}

cmd_logs() {
  # bunctl logs [name] [-f] [-n N]
  local name="" follow=false lines=100
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -f|--follow) follow=true; shift;;
      -n) lines="${2:-100}"; shift 2;;
      *) name="$1"; shift;;
    esac
  done
  if [[ -n "$name" ]]; then
    local unit="$(instance_unit_name "$(sanitize_name "$name")")"
    if $follow; then jc -u "$unit" -e -n "$lines" -f; else jc -u "$unit" -e -n "$lines"; fi
  else
    # all bunctl units
    if $follow; then jc -u "${UNIT_PREFIX}*" -e -n "$lines" -f; else jc -u "${UNIT_PREFIX}*" -e -n "$lines"; fi
  fi
}

cmd_env() {
  # bunctl env <name> set KEY=VAL | unset KEY
  local name="$(sanitize_name "${1:-}")"; shift || true
  [[ -z "$name" ]] && die "Usage: bunctl env <name> set KEY=VAL | unset KEY"
  local sub="${1:-}"; shift || true
  local envf="$(env_file_path "$name")"
  case "$sub" in
    set)
      local kv="${1:-}"; [[ "$kv" =~ ^[A-Za-z_][A-Za-z0-9_]*=.+$ ]] || die "Use KEY=value"
      local key="${kv%%=*}" val="${kv#*=}"
      kv_set "$envf" "$key" "$val"
      ok "Set ${key} for ${name} in ${envf}"
      warn "Restart to apply: bunctl restart $name"
      ;;
    unset)
      local key="${1:-}"; [[ -z "$key" ]] && die "Provide key to unset"
      kv_unset "$envf" "$key"
      ok "Unset ${key} for ${name}"
      warn "Restart to apply: bunctl restart $name"
      ;;
    *) die "Unknown env action. Use: bunctl env <name> set KEY=VAL | unset KEY";;
  }
}

cmd_health() {
  local name="$(sanitize_name "${1:-}")"; [[ -z "$name" ]] && die "Usage: bunctl health <name>"
  local unit="$(instance_unit_name "$name")"
  echo "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
  echo "${CYAN}Health Report: ${name}${RESET}"
  echo "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
  local active="$(sc is-active "$unit" 2>/dev/null || echo unknown)"
  local enabled="$(sc is-enabled "$unit" 2>/dev/null || echo disabled)"
  local pid="$(sc show "$unit" --property=MainPID --value 2>/dev/null || echo 0)"
  local restarts="$(sc show "$unit" --property=NRestarts --value 2>/dev/null || echo 0)"
  echo "Status:       $active"
  echo "Boot startup: $enabled"
  [[ "$pid" != "0" ]] && echo "PID:          $pid"
  if [[ "$pid" != "0" ]]; then
    local mem_kb="$(ps -o rss= -p "$pid" 2>/dev/null | tr -d ' ' || echo 0)"
    if [[ "$mem_kb" -gt 0 ]]; then
      if (( mem_kb < 1024 )); then echo "Memory:       ${mem_kb} KB"
      elif (( mem_kb < 1048576 )); then echo "Memory:       $(awk "BEGIN{printf \"%.1f MB\", $mem_kb/1024}")"
      else echo "Memory:       $(awk "BEGIN{printf \"%.1f GB\", $mem_kb/1048576}")"; fi
    fi
  fi
  echo "Restarts:     $restarts"
  if [[ "$active" == "failed" ]]; then
    echo; echo "${RED}Recent error logs:${RESET}"
    jc -u "$unit" -n 20 --no-pager || true
  fi
}

cmd_restart_all() {
  local parallel=false wait_health=false
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --parallel) parallel=true; shift;;
      --wait) wait_health=true; shift;;
      *) shift;;
    esac
  done
  local names=( $(list_instances) )
  [[ ${#names[@]} -eq 0 ]] && { warn "No apps"; return 0; }
  info "Restarting ${#names[@]} apps"
  if $parallel; then
    for n in "${names[@]}"; do sc restart "$(instance_unit_name "$n")" & done
    wait
  else
    for n in "${names[@]}"; do sc restart "$(instance_unit_name "$n")"; done
  fi
  if $wait_health; then
    for n in "${names[@]}"; do
      sc is-active --quiet "$(instance_unit_name "$n")" || die "App failed: $n"
    done
  fi
  ok "Restarted ${#names[@]} apps"
}

cmd_restart_group() {
  local pattern="${1:-}"; [[ -z "$pattern" ]] && die "Usage: bunctl restart-group '<glob>'"
  local names=( )
  while read -r n; do [[ "$n" == $pattern ]] && names+=( "$n" ); done < <(list_instances)
  [[ ${#names[@]} -eq 0 ]] && { warn "No apps match: $pattern"; return 0; }
  info "Restarting: ${names[*]}"
  for n in "${names[@]}"; do sc restart "$(instance_unit_name "$n")"; done
  ok "Done"
}

cmd_update() {
  # Regenerate drop-ins from configs (when you changed .json manually)
  local names=( )
  if [[ $# -gt 0 ]]; then names=( "$@" ); else mapfile -t names < <(list_instances); fi
  [[ ${#names[@]} -eq 0 ]] && { warn "No apps"; return 0; }
  for n in "${names[@]}"; do
    local cfg="$(config_path "$n")"
    if [[ -f "$cfg" ]]; then
      local cwd="$(jq -r '.cwd // ""' "$cfg" 2>/dev/null || echo "")"
      local memory="$(jq -r '.memory // ""' "$cfg" 2>/dev/null || echo "")"
      local cpu="$(jq -r '.cpu // ""' "$cfg" 2>/dev/null || echo "")"
      write_instance_dropin "$n" "${cwd:-$(pwd)}" "$memory" "$cpu" "" ""
    else
      warn "No config for $n, skipping"
    fi
  done
  sc daemon-reload
  ok "Updated ${#names[@]} app(s)"
}

cmd_list() { list_instances; }

cmd_logs_all() { cmd_logs -f; }

cmd_version() { echo "bunctl version $VERSION"; }

cmd_install_completion() {
  local dst="/etc/bash_completion.d/bunctl"
  is_root || die "Run as root to install bash completion"
  cat >"$dst" <<'COMP'
_bunctl_complete() {
  local cur prev
  COMPREPLY=()
  cur="${COMP_WORDS[COMP_CWORD]}"
  prev="${COMP_WORDS[COMP_CWORD-1]}"
  local cmds="init start stop restart reload delete enable disable status logs env health restart-all restart-group update list version"
  if [[ $COMP_CWORD -eq 1 ]]; then
    COMPREPLY=( $(compgen -W "$cmds" -- "$cur") )
    return 0
  fi
  case "${COMP_WORDS[1]}" in
    start|stop|restart|reload|delete|enable|disable|status|logs|env|health)
      local names="$(systemctl list-units --all --no-legend 'bunctl@*.service' 2>/dev/null | awk '{print $1}' | sed -E 's/^bunctl@//; s/\.service$//' )"
      COMPREPLY=( $(compgen -W "$names" -- "$cur") )
      ;;
    restart-group)
      COMPREPLY=()
      ;;
  esac
}
complete -F _bunctl_complete bunctl
COMP
  ok "Installed completion to $dst"
}

usage() {
cat <<USAGE
${BOLD}bunctl${RESET} — systemd-based PM2 replacement for Bun

${BOLD}Usage:${RESET}
  bunctl [--user|--system] <command> [args]

${BOLD}Common commands:${RESET}
  init [--name NAME] [--entry FILE] [--port N] [--cwd DIR] [--memory 512M] [--cpu 50] [--runtime bun|node] [--autostart]
  start <name>            stop <name>           restart <name>         reload <name>
  enable <name>           disable <name>        delete <name>
  status [--json] [name]  logs [name] [-f] [-n N]   env <name> (set KEY=VAL|unset KEY)
  health <name>           list                  restart-all [--parallel] [--wait]
  restart-group '<glob>'  update [name ...]
  version                 install-completion

${BOLD}Environment:${RESET}
  BUNCTL_MODE=user|system|auto   Default: auto (user units when not root)

Docs: README.md
USAGE
}

# ----------------------------
# entrypoint
# ----------------------------
main() {
  require_cmd systemctl
  case "${1:-}" in
    --user|--system) [[ "${1}" == "--user" ]] && MODE="user" || MODE="system"; shift;;
  esac
  local cmd="${1:-}"; shift || true
  case "$cmd" in
    init) cmd_init "$@";;
    start) cmd_start "$@";;
    stop) cmd_stop "$@";;
    restart) cmd_restart "$@";;
    reload) cmd_reload "$@";;
    delete) cmd_delete "$@";;
    enable) cmd_enable "$@";;
    disable) cmd_disable "$@";;
    status) cmd_status "$@";;
    logs) cmd_logs "$@";;
    env) cmd_env "$@";;
    health) cmd_health "$@";;
    restart-all) cmd_restart_all "$@";;
    restart-group) cmd_restart_group "$@";;
    update) cmd_update "$@";;
    list) cmd_list "$@";;
    version|--version|-v) cmd_version;;
    install-completion) cmd_install_completion;;
    ""|-h|--help|help) usage;;
    *) usage; exit 1;;
  esac
}

main "$@"
